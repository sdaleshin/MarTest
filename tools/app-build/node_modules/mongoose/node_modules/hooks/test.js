var hooks=require("./hooks"),should=require("should"),assert=require("assert"),_=require("underscore");module.exports={"should be able to assign multiple hooks at once":function(){var e=function(){};_.extend(e,hooks),e.hook({hook1:function(e){},hook2:function(e){}});var t=new e;assert.equal(typeof t.hook1,"function"),assert.equal(typeof t.hook2,"function")},"should run without pres and posts when not present":function(){var e=function(){};_.extend(e,hooks),e.hook("save",function(){this.value=1});var t=new e;t.save(),t.value.should.equal(1)},"should run with pres when present":function(){var e=function(){};_.extend(e,hooks),e.hook("save",function(){this.value=1}),e.pre("save",function(e){this.preValue=2,e()});var t=new e;t.save(),t.value.should.equal(1),t.preValue.should.equal(2)},"should run with posts when present":function(){var e=function(){};_.extend(e,hooks),e.hook("save",function(){this.value=1}),e.post("save",function(e){this.value=2,e()});var t=new e;t.save(),t.value.should.equal(2)},"should run pres and posts when present":function(){var e=function(){};_.extend(e,hooks),e.hook("save",function(){this.value=1}),e.pre("save",function(e){this.preValue=2,e()}),e.post("save",function(e){this.value=3,e()});var t=new e;t.save(),t.value.should.equal(3),t.preValue.should.equal(2)},"should run posts after pres":function(){var e=function(){};_.extend(e,hooks),e.hook("save",function(){this.value=1}),e.pre("save",function(e){this.override=100,e()}),e.post("save",function(e){this.override=200,e()});var t=new e;t.save(),t.value.should.equal(1),t.override.should.equal(200)},"should not run a hook if a pre fails":function(){var e=function(){};_.extend(e,hooks);var t=0;e.hook("save",function(){this.value=1},function(e){t++}),e.pre("save",!0,function(e,t){e(new Error)});var n=new e;n.save(),t.should.equal(1),assert.equal(typeof n.value,"undefined")},"should be able to run multiple pres":function(){var e=function(){};_.extend(e,hooks),e.hook("save",function(){this.value=1}),e.pre("save",function(e){this.v1=1,e()}).pre("save",function(e){this.v2=2,e()});var t=new e;t.save(),t.v1.should.equal(1),t.v2.should.equal(2)},"should run multiple pres until a pre fails and not call the hook":function(){var e=function(){};_.extend(e,hooks),e.hook("save",function(){this.value=1},function(e){}),e.pre("save",function(e){this.v1=1,e()}).pre("save",function(e){e(new Error)}).pre("save",function(e){this.v3=3,e()});var t=new e;t.save(),t.v1.should.equal(1),assert.equal(typeof t.v3,"undefined"),assert.equal(typeof t.value,"undefined")},"should be able to run multiple posts":function(){var e=function(){};_.extend(e,hooks),e.hook("save",function(){this.value=1}),e.post("save",function(e){this.value=2,e()}).post("save",function(e){this.value=3.14,e()}).post("save",function(e){this.v3=3,e()});var t=new e;t.save(),assert.equal(t.value,3.14),assert.equal(t.v3,3)},"should run only posts up until an error":function(){var e=function(){};_.extend(e,hooks),e.hook("save",function(){this.value=1},function(e){}),e.post("save",function(e){this.value=2,e()}).post("save",function(e){this.value=3,e(new Error)}).post("save",function(e){this.value=4,e()});var t=new e;t.save(),t.value.should.equal(3)},"should fall back first to the hook method's last argument as the error handler if it is a function of arity 1 or 2":function(){var e=function(){};_.extend(e,hooks);var t=0;e.hook("save",function(e){this.value=1}),e.pre("save",!0,function(e,t){e(new Error)});var n=new e;n.save(function(e){e instanceof Error&&t++}),t.should.equal(1),should.deepEqual(undefined,n.value)},"should fall back second to the default error handler if specified":function(){var e=function(){};_.extend(e,hooks);var t=0;e.hook("save",function(e){this.value=1},function(e){e instanceof Error&&t++}),e.pre("save",!0,function(e,t){e(new Error)});var n=new e;n.save(),t.should.equal(1),should.deepEqual(undefined,n.value)},"fallback default error handler should scope to the object":function(){var e=function(){this.counter=0};_.extend(e,hooks);var t=0;e.hook("save",function(e){this.value=1},function(e){e instanceof Error&&this.counter++}),e.pre("save",!0,function(e,t){e(new Error)});var n=new e;n.save(),n.counter.should.equal(1),should.deepEqual(undefined,n.value)},"should fall back last to throwing the error":function(){var e=function(){};_.extend(e,hooks);var t=0;e.hook("save",function(e){if(e instanceof Error)return t++;this.value=1}),e.pre("save",!0,function(e,t){e(new Error)});var n=new e,r=!1;try{n.save()}catch(i){r=!0,i.should.be.an.instanceof(Error),t.should.equal(0),assert.equal(typeof n.value,"undefined")}r.should.be.true},"should proceed without mutating arguments if `next(null|undefined)` is called in a serial pre, and the last argument of the target method is a callback with node-like signature function (err, obj) {...} or function (err) {...}":function(){var e=function(){};_.extend(e,hooks);var t=0;e.prototype.save=function(e){this.value=1,e()},e.pre("save",function(e){e(null)}),e.pre("save",function(e){e(undefined)});var n=new e;n.save(function(e){e instanceof Error?t++:t--}),t.should.equal(-1),n.value.should.eql(1)},"should proceed with mutating arguments if `next(null|undefined)` is callback in a serial pre, and the last argument of the target method is not a function":function(){var e=function(){};_.extend(e,hooks),e.prototype.set=function(e){this.value=e},e.pre("set",function(e){e(undefined)}),e.pre("set",function(e){e(null)});var t=new e;t.set(1),should.strictEqual(null,t.value)},"should not run any posts if a pre fails":function(){var e=function(){};_.extend(e,hooks),e.hook("save",function(){this.value=2},function(e){}),e.pre("save",function(e){this.value=1,e(new Error)}).post("save",function(e){this.value=3,e()});var t=new e;t.save(),t.value.should.equal(1)},"can pass the hook's arguments verbatim to pres":function(){var e=function(){};_.extend(e,hooks),e.hook("set",function(e,t){this[e]=t}),e.pre("set",function(e,t,n){t.should.equal("hello"),n.should.equal("world"),e()});var t=new e;t.set("hello","world"),t.hello.should.equal("world")},"can pass the hook's arguments verbatim to posts":function(){var e=function(){};_.extend(e,hooks),e.hook("set",function(e,t){this[e]=t}),e.post("set",function(e,t,n){t.should.equal("hello"),n.should.equal("world"),e()});var t=new e;t.set("hello","world"),assert.equal(t.hello,"world")},"pres should be able to modify and pass on a modified version of the hook's arguments":function(){var e=function(){};_.extend(e,hooks),e.hook("set",function(e,t){this[e]=t,assert.equal(arguments[2],"optional")}),e.pre("set",function(e,t,n){e("foo","bar")}),e.pre("set",function(e,t,n){assert.equal(t,"foo"),assert.equal(n,"bar"),e("rock","says","optional")}),e.pre("set",function(e,t,n,r){assert.equal(t,"rock"),assert.equal(n,"says"),assert.equal(r,"optional"),e()});var t=new e;t.set("hello","world"),assert.equal(typeof t.hello,"undefined"),t.rock.should.equal("says")},"posts should see the modified version of arguments if the pres modified them":function(){var e=function(){};_.extend(e,hooks),e.hook("set",function(e,t){this[e]=t}),e.pre("set",function(e,t,n){e("foo","bar")}),e.post("set",function(e,t,n){t.should.equal("foo"),n.should.equal("bar")});var t=new e;t.set("hello","world"),assert.equal(typeof t.hello,"undefined"),t.foo.should.equal("bar")},"should pad missing arguments (relative to expected arguments of the hook) with null":function(){var e=function(){};_.extend(e,hooks),e.hook("set",function(e,t,n){this[e]=t}),e.pre("set",function(e,t,n,r){e("foo","bar"),assert.equal(typeof r,"undefined")});var t=new e;t.set("hello","world")},"should not invoke the target method until all asynchronous middleware have invoked dones":function(){var e=0,t=function(){};_.extend(t,hooks),t.hook("set",function(t,n){e++,this[t]=n,e.should.equal(7)}),t.pre("set",function(t,n,r){e++,t()}),t.pre("set",!0,function(t,n,r,i){e++,setTimeout(function(){e++,n()},1e3),t()}),t.pre("set",function(t,n,r){e++,t()}),t.pre("set",!0,function(t,n,r,i){e++,setTimeout(function(){e++,n()},500),t()});var n=new t;n.set("hello","world")},"invoking a method twice should run its async middleware twice":function(){var e=0,t=function(){};_.extend(t,hooks),t.hook("set",function(t,n){this[t]=n,t==="hello"&&e.should.equal(1),t==="foo"&&e.should.equal(2)}),t.pre("set",!0,function(t,n,r,i){setTimeout(function(){e++,n()},1e3),t()});var n=new t;n.set("hello","world"),n.set("foo","bar")},"calling the same done multiple times should have the effect of only calling it once":function(){var e=function(){this.acked=!1};_.extend(e,hooks),e.hook("ack",function(){console.log("UH OH, YOU SHOULD NOT BE SEEING THIS"),this.acked=!0}),e.pre("ack",!0,function(e,t){e(),t(),t()}),e.pre("ack",!0,function(e,t){e()});var t=new e;t.ack(),setTimeout(function(){t.acked.should.be.false},1e3)},"calling the same next multiple times should have the effect of only calling it once":function(e){var t=function(){this.acked=!1};_.extend(t,hooks),t.hook("ack",function(){console.log("UH OH, YOU SHOULD NOT BE SEEING THIS"),this.acked=!0}),t.pre("ack",function(e){try{e(new Error("bam"))}catch(t){e()}}),t.pre("ack",function(e){e()});var n=new t;n.ack(),e(function(){n.acked.should.be.false})},"asynchronous middleware should be able to pass an error via `done`, stopping the middleware chain":function(){var e=0,t=function(){};_.extend(t,hooks),t.hook("set",function(t,n,r){e++,this[t]=n,r(null)}),t.pre("set",!0,function(t,n,r,i,s){setTimeout(function(){e++,n(new Error)},1e3),t()});var n=new t;n.set("hello","world",function(t){t.should.be.an.instanceof(Error),should.strictEqual(undefined,n.hello),e.should.eql(1)})},"should be able to remove a particular pre":function(){var e=function(){},t;_.extend(e,hooks),e.hook("save",function(){this.value=1}),e.pre("save",function(e){this.preValueOne=2,e()}),e.pre("save",t=function(e){this.preValueTwo=4,e()}),e.removePre("save",t);var n=new e;n.save(),n.value.should.equal(1),n.preValueOne.should.equal(2),should.strictEqual(undefined,n.preValueTwo)},"should be able to remove all pres associated with a hook":function(){var e=function(){};_.extend(e,hooks),e.hook("save",function(){this.value=1}),e.pre("save",function(e){this.preValueOne=2,e()}),e.pre("save",function(e){this.preValueTwo=4,e()}),e.removePre("save");var t=new e;t.save(),t.value.should.equal(1),should.strictEqual(undefined,t.preValueOne),should.strictEqual(undefined,t.preValueTwo)},"#pre should lazily make a method hookable":function(){var e=function(){};_.extend(e,hooks),e.prototype.save=function(){this.value=1},e.pre("save",function(e){this.preValue=2,e()});var t=new e;t.save(),t.value.should.equal(1),t.preValue.should.equal(2)},"#pre lazily making a method hookable should be able to provide a default errorHandler as the last argument":function(){var e=function(){},t="";_.extend(e,hooks),e.prototype.save=function(){this.value=1},e.pre("save",function(e){e(new Error)},function(e){t="ERROR"});var n=new e;n.save(),should.strictEqual(undefined,n.value),t.should.equal("ERROR")},"#post should lazily make a method hookable":function(){var e=function(){};_.extend(e,hooks),e.prototype.save=function(){this.value=1},e.post("save",function(e){this.value=2,e()});var t=new e;t.save(),t.value.should.equal(2)},"a lazy hooks setup should handle errors via a method's last argument, if it's a callback":function(){var e=function(){};_.extend(e,hooks),e.prototype.save=function(e){},e.pre("save",function(e){e(new Error("hi there"))});var t=new e;t.save(function(e){e.should.be.an.instanceof(Error)})}};