/*!
 * Module dependencies
 */

/*!
 * define methods
 */

/*!
 * Helpers
 */

/*!
 * Exports
 */

function Aggregate(){this._pipeline=[],this._model=undefined,this.options=undefined,1===arguments.length&&util.isArray(arguments[0])?this.append.apply(this,arguments[0]):this.append.apply(this,arguments)}function isOperator(e){var t;return"object"!=typeof e?!1:(t=Object.keys(e),1===t.length&&t.some(function(e){return"$"===e[0]}))}var Promise=require("./promise"),util=require("util"),utils=require("./utils"),Query=require("./query"),read=Query.prototype.read;Aggregate.prototype.bind=function(e){return this._model=e,this},Aggregate.prototype.append=function(){var e=utils.args(arguments),t;if(!e.every(isOperator))throw new Error("Arguments must be aggregate pipeline operators");return this._pipeline=this._pipeline.concat(e),this},Aggregate.prototype.project=function(e){var t={};if("object"==typeof e&&!util.isArray(e))Object.keys(e).forEach(function(n){t[n]=e[n]});else{if(1!==arguments.length||"string"!=typeof e)throw new Error("Invalid project() argument. Must be string or object");e.split(/\s+/).forEach(function(e){if(!e)return;var n="-"==e[0]?0:1;n===0&&(e=e.substring(1)),t[e]=n})}return this.append({$project:t})},Aggregate.prototype.near=function(e){var t={};return t.$geoNear=e,this.append(t)},"group match skip limit".split(" ").forEach(function(e){Aggregate.prototype[e]=function(t){var n={};return n["$"+e]=t,this.append(n)}}),Aggregate.prototype.unwind=function(){var e=utils.args(arguments);return this.append.apply(this,e.map(function(e){return{$unwind:"$"+e}}))},Aggregate.prototype.sort=function(e){var t={};if("Object"===e.constructor.name){var n=["desc","descending",-1];Object.keys(e).forEach(function(r){t[r]=n.indexOf(e[r])===-1?1:-1})}else{if(1!==arguments.length||"string"!=typeof e)throw new TypeError("Invalid sort() argument. Must be a string or object.");e.split(/\s+/).forEach(function(e){if(!e)return;var n="-"==e[0]?-1:1;n===-1&&(e=e.substring(1)),t[e]=n})}return this.append({$sort:t})},Aggregate.prototype.read=function(e){return this.options||(this.options={}),read.apply(this,arguments),this},Aggregate.prototype.exec=function(e){var t=new Promise;return e&&t.addBack(e),this._pipeline.length?this._model?(this._model.collection.aggregate(this._pipeline,this.options||{},t.resolve.bind(t)),t):(t.error(new Error("Aggregate not bound to any Model")),t):(t.error(new Error("Aggregate has empty pipeline")),t)},module.exports=Aggregate;