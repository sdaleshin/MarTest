/*!
 * Module dependencies.
 */

/*!
 * Inherits from SchemaType.
 */

/*!
 * @ignore
 *
 * $atomic cast helpers
 */

/*!
 * Module exports.
 */

function SchemaArray(e,t,n){if(t){var r={};"Object"===t.constructor.name&&(t.type?(r=utils.clone(t),delete r.type,t=t.type):t=Mixed);var i="string"==typeof t?t:t.name,s=i in Types?Types[i]:t;this.casterConstructor=s,this.caster=new s(null,r),this.caster instanceof EmbeddedDoc||(this.caster.path=e)}SchemaType.call(this,e,n);var o=this,u,a;this.defaultValue&&(u=this.defaultValue,a="function"==typeof u),this.default(function(){var e=a?u():u||[];return new MongooseArray(e,o.path,this)})}function castToNumber(e){return Types.Number.prototype.cast.call(this,e)}function castArraysOfNumbers(e,t){t||(t=this),e.forEach(function(n,r){Array.isArray(n)?castArraysOfNumbers(n,t):e[r]=castToNumber.call(t,n)})}function cast$near(e){return Array.isArray(e)?(castArraysOfNumbers(e,this),e):e&&e.$geometry?cast$geometry(e,this):SchemaArray.prototype.castForQuery.call(this,e)}function cast$geometry(e,t){switch(e.$geometry.type){case"Polygon":case"LineString":case"Point":castArraysOfNumbers(e.$geometry.coordinates,t);break;default:}return e.$maxDistance&&(e.$maxDistance=castToNumber.call(t,e.$maxDistance)),e}function cast$within(e){var t=this;e.$maxDistance&&(e.$maxDistance=castToNumber.call(t,e.$maxDistance));if(e.$box||e.$polygon){var n=e.$box?"$box":"$polygon";e[n].forEach(function(e){if(!Array.isArray(e)){var t="Invalid $within $box argument. Expected an array, received "+e;throw new TypeError(t)}e.forEach(function(t,n){e[n]=castToNumber.call(this,t)})})}else if(e.$center||e.$centerSphere){var n=e.$center?"$center":"$centerSphere";e[n].forEach(function(t,r){Array.isArray(t)?t.forEach(function(e,n){t[n]=castToNumber.call(this,e)}):e[n][r]=castToNumber.call(this,t)})}else e.$geometry&&cast$geometry(e,this);return e}function cast$all(e){return Array.isArray(e)||(e=[e]),e=e.map(function(e){if(utils.isObject(e)){var t={};t[this.path]=e;var n=new Query(t);return n.cast(this.casterConstructor),n._conditions[this.path]}return e},this),this.castForQuery(e)}function cast$elemMatch(e){if(e.$in)return e.$in=this.castForQuery("$in",e.$in),e;var t=new Query(e);return t.cast(this.casterConstructor),t._conditions}function cast$geoIntersects(e){var t=e.$geometry;if(!t)return;return cast$geometry(e,this),e}var SchemaType=require("../schematype"),CastError=SchemaType.CastError,NumberSchema=require("./number"),Types={Boolean:require("./boolean"),Date:require("./date"),Number:require("./number"),String:require("./string"),ObjectId:require("./objectid"),Buffer:require("./buffer")},MongooseArray=require("../types").Array,EmbeddedDoc=require("../types").Embedded,Mixed=require("./mixed"),Query=require("../query"),utils=require("../utils"),isMongooseObject=utils.isMongooseObject;SchemaArray.prototype.__proto__=SchemaType.prototype,SchemaArray.prototype.checkRequired=function(e){return!!e&&!!e.length},SchemaArray.prototype.applyGetters=function(e,t){return this.caster.options&&this.caster.options.ref?e:SchemaType.prototype.applyGetters.call(this,e,t)},SchemaArray.prototype.cast=function(e,t,n){if(Array.isArray(e)){if(!e.length&&t){var r=t.schema.indexedPaths();for(var i=0,s=r.length;i<s;++i){var o=r[i][0][this.path];if("2dsphere"===o||"2d"===o)return}}e instanceof MongooseArray||(e=new MongooseArray(e,this.path,t));if(this.caster)try{for(var i=0,s=e.length;i<s;i++)e[i]=this.caster.cast(e[i],t,n)}catch(u){throw new CastError(u.type,e,this.path)}return e}return this.cast([e],t,n)},SchemaArray.prototype.castForQuery=function(e,t){var n,r;if(arguments.length===2){n=this.$conditionalHandlers[e];if(!n)throw new Error("Can't use "+e+" with Array.");r=n.call(this,t)}else{r=e;var i=this.casterConstructor.prototype,s=i.castForQuery||i.cast,o=this.caster;Array.isArray(r)?r=r.map(function(e){return s&&(e=s.call(o,e)),isMongooseObject(e)?e.toObject():e}):s&&(r=s.call(o,r))}return r&&isMongooseObject(r)?r.toObject():r};var handle=SchemaArray.prototype.$conditionalHandlers={};handle.$all=cast$all,handle.$options=String,handle.$elemMatch=cast$elemMatch,handle.$geoIntersects=cast$geoIntersects,handle.$near=handle.$nearSphere=cast$near,handle.$within=handle.$geoWithin=cast$within,handle.$size=handle.$maxDistance=castToNumber,handle.$regex=handle.$ne=handle.$in=handle.$nin=handle.$gt=handle.$gte=handle.$lt=handle.$lte=SchemaArray.prototype.castForQuery,module.exports=SchemaArray;