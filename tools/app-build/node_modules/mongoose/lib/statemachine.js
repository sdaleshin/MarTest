/*!
 * Module dependencies.
 */

/*!
 * StateMachine represents a minimal `interface` for the
 * constructors it builds via StateMachine.ctor(...).
 *
 * @api private
 */

/*!
 * StateMachine.ctor('state1', 'state2', ...)
 * A factory method for subclassing StateMachine.
 * The arguments are a list of states. For each state,
 * the constructor's prototype gets state transition
 * methods named after each state. These transition methods
 * place their path argument into the given state.
 *
 * @param {String} state
 * @param {String} [state]
 * @return {Function} subclass constructor
 * @private
 */

/*!
 * This function is wrapped by the state change functions:
 *
 * - `require(path)`
 * - `modify(path)`
 * - `init(path)`
 *
 * @api private
 */

/*!
 * ignore
 */

/*!
 * Checks to see if at least one path is in the states passed in via `arguments`
 * e.g., this.some('required', 'inited')
 *
 * @param {String} state that we want to check for.
 * @private
 */

/*!
 * This function builds the functions that get assigned to `forEach` and `map`,
 * since both of those methods share a lot of the same logic.
 *
 * @param {String} iterMethod is either 'forEach' or 'map'
 * @return {Function}
 * @api private
 */

/*!
 * Iterates over the paths that belong to one of the parameter states.
 *
 * The function profile can look like:
 * this.forEach(state1, fn);         // iterates over all paths in state1
 * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2
 * this.forEach(fn);                 // iterates over all paths in all states
 *
 * @param {String} [state]
 * @param {String} [state]
 * @param {Function} callback
 * @private
 */

/*!
 * Maps over the paths that belong to one of the parameter states.
 *
 * The function profile can look like:
 * this.forEach(state1, fn);         // iterates over all paths in state1
 * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2
 * this.forEach(fn);                 // iterates over all paths in all states
 *
 * @param {String} [state]
 * @param {String} [state]
 * @param {Function} callback
 * @return {Array}
 * @private
 */

var utils=require("./utils"),StateMachine=module.exports=exports=function(){this.paths={},this.states={}};StateMachine.ctor=function(){var e=utils.args(arguments),t=function(){StateMachine.apply(this,arguments),this.stateNames=e;var t=e.length,n;while(t--)n=e[t],this.states[n]={}};return t.prototype.__proto__=StateMachine.prototype,e.forEach(function(e){t.prototype[e]=function(t){this._changeState(t,e)}}),t},StateMachine.prototype._changeState=function(t,n){var r=this.states[this.paths[t]];r&&delete r[t],this.paths[t]=n,this.states[n][t]=!0},StateMachine.prototype.clear=function(t){var n=Object.keys(this.states[t]),r=n.length,i;while(r--)i=n[r],delete this.states[t][i],delete this.paths[i]},StateMachine.prototype.some=function(){var t=this,n=arguments.length?arguments:this.stateNames;return Array.prototype.some.call(n,function(e){return Object.keys(t.states[e]).length})},StateMachine.prototype._iter=function(t){return function(){var e=arguments.length,n=utils.args(arguments,0,e-1),r=arguments[e-1];n.length||(n=this.stateNames);var i=this,s=n.reduce(function(e,t){return e.concat(Object.keys(i.states[t]))},[]);return s[t](function(e,t,n){return r(e,t,n)})}},StateMachine.prototype.forEach=function(){return this.forEach=this._iter("forEach"),this.forEach.apply(this,arguments)},StateMachine.prototype.map=function(){return this.map=this._iter("map"),this.map.apply(this,arguments)};